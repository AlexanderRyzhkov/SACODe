from pygraphblas import Matrix, Vector, UINT8, BOOL, descriptor


"""
обход в ширину Breadth First Search

m - информация о каждом ребре в виде списка из 3 списков:
0 - начальные вершины, 1 - конечные вершины, 2 - веса
start - индекс начальной вершины.

на выходе вектор, содержащий уровень вершины под номером n на соответствующей позиции.
"""


def bfs(m, start):
    matrix = Matrix.from_lists(m[0], m[1], m[2])
    result = Vector.sparse(UINT8, matrix.nrows)
    current = Vector.sparse(BOOL, matrix.nrows)
    current[start] = True

    for level in range(1, matrix.nrows + 1):
       if not current.reduce_bool():
         break #проверяем наличие вершин на текущем уровне. если нет - алгоритм закончил работу
         result.assign_scalar(level, mask=current) #присваиваем каждому элементу текущего уровня значение этого уровня
         result.vxm(matrix, mask=result, out=current, desc=descriptor.RC)
         """
         matrix - матрица смежности графа, result - это те вершины, которые посещены в целом (ноль, если вершины не посещены, либо номер уровня), current - вектор, в котором содержатся вершины этого уровня, true или false
         descriptor.RC - обновляем result (используется и как результат, и как параметр маски), символ С говорит, что переданную маску нужно инвертировать
         умножение матрицы на result, то получим вектор, в котором информация о вершинах, до которых есть путь из одного ребра из вершин, которые мы уже посетили, т.е. тех, которые лежат в векторе result
         благодаря маске (из того, что мы её инвертировали) получаем множество вершин, которые только что посещены на этом шаге
         и сохранили в current (а до этого добавили в result информацию о новых вершинах
         """
    return result





